# 第四次理论作业

## 一、冒泡排序

首先写出C代码如下：

```C
int A[10] = { ... };

printf("Please input 10 numbers:\n");

for (int i = 0; i <= 9; i++) scanf("%d", &A[i]);

for (int i = 0; i <= 8; i++) {
    for (int j = 0; j <= 8 - i; j++) {
        if (A[j] > A[j + 1]) {
            int temp = A[j];
            A[j] = A[j + 1];
            A[j + 1] = temp;
        }
    }
}

printf("Sorted 10 numbers is:\n");

for (int i = 0; i <= 9; i++) printf("%d", A[i]);
```

翻译如下：

```Shell
.data
space: .asciiz " "
welcome: .asciiz "Please input 10 numbers:\n"
sorted: .asciiz "Sorted 10 numbers is:\n"

.text
.globl main

main:
    li $t0, 0
    li $t1, 10
    li $t2, 9
    li $t3, 0
    li $t4, 0

    li $v0, 4
    la $a0, welcome
    syscall

read_loop:
    beq $t0, $t1, sort
    la $a0, A
    mul $a1, $t0, 4
    add $a0, $a0, $a1
    li $v0, 5
    syscall
    sw $v0, 0($a0)
    addi $t0, $t0, 1
    j read_loop

sort:
    li $t0, 0
outer_loop:
    li $t3, 0
inner_loop:
    la $a0, A
    mul $t5, $t3, 4
    add $a0, $a0, $t5
    addi $a1, $a0, 4

    lw $t5, 0($a0)
    lw $t6, 0($a1)

    ble $t5, $t6, no_swap

    sw $t6, 0($a0)
    sw $t5, 0($a1)

no_swap:
    addi $t3, $t3, 1
    bne $t3, $t2, inner_loop

    addi $t0, $t0, 1
    bne $t0, $t1, outer_loop

    li $v0, 4
    la $a0, sorted
    syscall

    li $t0, 0
print_loop:
    beq $t0, $t1, done
    la $a0, A
    mul $a1, $t0, 4
    add $a0, $a0, $a1
    lw $a0, 0($a0)
    li $v0, 1
    syscall
    li $v0, 4
    la $a0, space
    syscall
    addi $t0, $t0, 1
    j print_loop

done:
    li $v0, 10
    syscall
```

代码截图如下：

<image src="image/4t/1.jpg">

在这里，`.data`段中为`A`预留了`4*10=40`字节的空间。并且设置了`space`以输出空格；`welcome`以输出输入提示语；`sorted`以输出排序完成提示语。

<image src="image/4t/2.jpg">

进入`main`后，我规定用`$t0`寄存外层变量`i`，`$t3`寄存内层变量`j`。同时，`$t1`寄存外层变量上限，即`10`；`$t2`寄存内层变量上限，即`9`。还有`$t4`用于寄存暂时变量`temp`。
之后调用字符串输出，输出输入提示语`welcome`。

<image src="image/4t/3.jpg">

之后进入读取十个数的循环，命名为`read_loop`。当`$t0`从`0`自增到`10`的时候(自增了`11`次，但剩余内容只执行了`10`次)即可跳到`sort`循环段。
首先加载`A`的首地址到`$a0`。之后通过此时的`i`值(在`$t0`中)计算出偏移量，即乘`4`(或左移两位)，再将`$a0`的值加上偏移量得到输入数的存放地址。读入数后存储，并使`i`自增`1`。

<image src="image/4t/4.jpg">

开始排序。首先计算出相应相邻位置的地址，然后比较大小。之后判断是否跳转。如果符合条件，则进入下一条语句以交换。否则跳入`no_swap`分支以规避值交换。

<image src="image/4t/5.jpg">

如果不符合条件，就无需交换数值，直接跳到此段`no_swap`。但`no_swap`无论是否符合条件都会生效。这一段实现`i`，`j`的自增，并判断应该跳到外循环还是内循环，还是已经排序完成到输出阶段。

<image src="image/4t/6.jpg">

最后是输出循环。输出十次之后即可停止，跳转到`done`标签，返回到操作系统。

运行结果如下：

<image src="image/4t/7.jpg">
<image src="image/4t/8.jpg">
<image src="image/4t/9.jpg">

在编写的过程中，我感受到汇编的思维过程与高级语言稍有差别。例如，从编写的便捷性来说，为了减少分支跳转，考虑到重复的过程，在汇编中事实上是判断为假才跳转。

---

## 二、阶乘

首先写出C代码如下：

```C
int main()
{
    int start = 0, result = 0;
    scanf("%d", &start);
    result = Fac(start);
    printf("%d", result);
}

int Fac(int n)
{
    if (n >= 2) return (n * Fac(n - 1));
    if (n == 1) return 1;
}
```

翻译如下：

```Shell
.data
Input: .asciiz "Input a number: "
Result: .asciiz "Result: "

.text
main:
    li $v0, 4
    la $a0, Input
    syscall

    li $v0, 5
    syscall

    move $t0, $v0
    move $t1, $t0
    li $a1, 1

Fac:
    addi $sp, $sp, -8
    sw $ra, 0($sp)
    sw $t1, 4($sp)
    beq $t1, 1, re0
    addi $t1, $t1, -1
    jal Fac

    lw $a0, 4($sp) 
    mult $a1, $a0
    mflo $a1
    beq $t1, $t0, done

re0:
    addi $t1, $t1, 1
    lw $ra, 0($sp)
    addi $sp, $sp, 8
    jr $ra

done:
    la $a0, Result
    li $v0, 4
    syscall

    move $a0, $a1
    li $v0, 1
    syscall

    li $v0, 10
    syscall
```

代码截图如下：

<image src="image/4t/10.jpg">

提示语存储在`data`段。

<image src="image/4t/11.jpg">

进入`main`函数之后，主要任务有三个：
其一，提示输入一个数；
其二，从键盘读取一个数；
其三，设置初始值。
在这里，规定`$t0`做存储`const`型数作用，而`$t1`在程序生命周期内做变量直到递减为`1`，`$a1`做中间/最后结果存储。

<image src="image/4t/12.jpg">

进入`Fac`段。首先压栈存值。直到`$t1`减为`1`跳到`re0`段，之后再一层层出栈(但这是`re0`的任务)。每次出栈将暂时结果乘以当前出栈的数值，最后判断`$t0==$t1`得到最终结果,跳到`done`执行最后指令段。

<image src="image/4t/13.jpg">

执行出栈。

<image src="image/4t/14.jpg">

输出`Result`字符串，输出最终结果，返回操作系统。

程序运行截图如下：

<image src="image/4t/15.jpg">

可以感受到，汇编的递归函数对思维有较高要求。高级语言隐藏了压栈出栈的过程，使得程序员能把更多心思花在数据本身上而不是程序如何运行上。

简便起见，假设递归深度为`2`，即要计算的是`3!`。堆栈变化简要图：

<image src="image/4t/16.jpg">
<image src="image/4t/17.jpg">

首先连入三次栈，每次都保存当时`$ra`，`$t1`。但由于`$a1`初始已经设置为`1`，故第一次入栈的`1`的值可以不出栈，即只需出栈两次。因此只需依次计算：
`$a1*2`,`($a1*2)*3`
即可。

在这里，直到`$t1`变为`1`，每次遇到`jal Fac`都将跳转到`Fac`标签，只压栈。

`$t1`变为`1`之后，跳入`re0`段，开始出栈。每次遇到`jr $ra`都将回到`jal Fac`的下一条语句`lw $a0, 4($sp)`，执行计算与取值。

直到`$t1`恢复为`3`，跳转到`done`执行程序最后阶段。
