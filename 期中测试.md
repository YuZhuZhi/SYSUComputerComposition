# 期中测试

## 一、选择题

$\begin{cases}
    &1.B\quad&2.C\quad&3.A\quad&4.D\quad&5.BF\quad\\
    &6.B\quad&7.A\quad&8.E\quad&9.A\quad&10.C\quad\\
\end{cases}$

---

## 二、填空题

这条指令是：`lw r4, -24556(r5)`

### 二、(1)

`sign-extend: 1111 1111 1111 1111 1010 0000 0001 0100`

`jump:无`

### 二、(2)

`new PC: PC + 4`

`path: PC---->Add--(+4)-->JumpMux--(Jump=0)-->PC`

### 二、(3)

|`WrRegMux`|`ALUMux`|`Mem/ALUMux`|`BranchMux`|`JumpMux`|
|:-:|:-:|:-:|:-:|:-:|
|`00100`|`1111 1111 1111 1111 1010 0000 0001 0100`|`0000 0000 0000 0000 0000 0000 0000 0000`|`NULL`|`PC+4`|

### 二、(4)

|`ALU`|`Add(PC+4)`|`Add(Branch)`|
|:-:|:-:|:-:|
|`10,-24556`|`PC,4`|`NULL`|

### 二、(5)

|`ReadReg1`|`ReadReg2`|`WriteReg`|`WriteData`|`RegWrite`|`RegDst`|`MemtoReg`|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|`00101`|`NULL`|`00100`|`(sign-extend)0`|`1`|`1`|`1`|

---

## 三、判断题

$\begin{cases}
    &1.F\quad&2.T\quad&3.T\\
    &4.T\quad&5.F\quad&6.T\\
\end{cases}$

---

## 四、判断题

(1)(3)正确。

---

## 五、分析题

### 五、1

因为`A8 H + CF H = 177 H`即`0001 0111 0111 B`

故`AL`内容为`0111 0111`

有进位、有溢出，符号位为`0`，两数不相等、产生结果不为`0`，故：

`CF = 1, OF = 1, SF = 0, ZF = 0`

### 五、2

(1)流水线中，时钟周期由最长的延迟决定，即`MEM`之延迟`500ns`。

非流水线中，时钟周期由最长指令决定即`lw`，这条指令需要经过所有五个阶段，故周期为`300+400+350+500+100=1650ns`

(2)流水线中，需要经过五个流水线中的时钟周期，即`500 * 5 = 2500ns`。

非流水线中，需要经过一个非流水线中的时钟周期，即`1650ns`。

### 五、3

`Seq1: Must stall`，第二条指令的`EX`阶段至少需要在第一条指令的`MEM`阶段后。

`Seq2: Avoid stall only forwarding`，第二条指令不与第一条指令数据冒险，但第三条指令的`EX`阶段恰为第一条指令的`WB`阶段，需要旁路。

`Seq3: Without stalling / forwarding`，各指令之间没有数据冒险。

### 五、4

(A)`5`

(B)`1 0000`

### 五、5

跳转并链接。跳转到指令指向的地址，并将下一指令地址存入`$ra`。

`$ra = 0040 0008 H`

`0100 0800 H`

---

## 六

```Shell
    add $t0, $zero, $zero \\$t0中存入0
loop: 
    beq $a1, $zero, finish \\若$a1等于0，则跳转到finish
    add $t0, $t0, $a0 \\$t0与$a0之和存入$t0
    sub $a1, $a1, 1 \\$a1与1之差存入$a1
    j loop \\跳转到loop
finish: 
    addi $t0, $t0, 100 \\$t0与100之和存入$t0
    add $v0, $t0, $zero \\$t0的值存入$v0
```

用循环计算$5\times6$，最后加上$100$

`$v0 = 130`

---

## 七

```Shell
.data
A: .space 400
B: .space 400

.text
.globl main

main:
    la $a0, A
    la $a1, B

    li $t0, 1
    li $t1, 100

loop:
    beq $t0, $t1, end
    lw $t2, ($a0)
    lw $t3, ($a1)
    add $t2, $t2, $t3
    addi $a0, $a0, 4
    sw $t2, ($a0)
    addi $a1, $a1, 4
    addi $t0, $t0, 1
    j loop
```

---

## 八

<image src="image/1.jpg">

$M$表示加减法。加法为$0$，减法为$1$。

电路原理是将原式变为补码的加法运算。补码的加法运算可以忽略符号位的影响。

因此首先用$M$异或第二个操作数的所有位以生成相应于加法运算的补码。

之后使用普通的行波进位加法器对相应补码做加法运算。$S_{1-4}$为相应每位的计算结果。

最后判断最高位进位$CF$即$C_3$与$M$的异或、以及溢出判断$OF$即$C_2$与$C_3$的异或。

---

## 九、`INT 49H`

```Shell
assume cs:code

code segment
start:
    ;安装中断例程
    mov ax, 0
    mov es, ax
    mov di, 200h
    mov ax, cs
    mov ds, ax
    mov si, offset intstart
    mov cx, offset intend - offset intstart
    cld
    rep movsb

    ;中断例程入口放入中断向量表
    mov word ptr es:[49h * 4], 200h 
    mov word ptr es:[49h * 4 + 2], 0

    int 49h ;引发中断

    mov ax, 4c00h
    int 21h

    ;中断例程代码
intstart:
    src1 dw 0
    src2 dw 0
    func dw 0
    msg1 db "Input Num1:", 0DH, 0AH, '$'
    msg2 db "Input Num2:", 0DH, 0AH, '$'
    msg3 db "Input Func:(1:+, 2:-)", 0DH, 0AH, '$'
    msg4 db "Result is:", 0DH, 0AH, '$'

start:
    ; 显示消息1
    mov ah, 09h
    lea dx, msg1
    int 21h

    ; 输入到src1
    mov ah, 0Ah
    lea dx, src1
    int 21h

    ; 显示消息2
    mov ah, 09h
    lea dx, msg2
    int 21h

    ; 输入到src2
    mov ah, 0Ah
    lea dx, src2
    int 21h

    ; 显示消息3
    mov ah, 09h
    lea dx, msg3
    int 21h

    ; 输入到func
    mov ah, 0Ah
    lea dx, func
    int 21h

    mov ax, [func] - '0'

    cmp ax, 1
    je add_case

    cmp ax, 2
    je sub_case

    jmp start

add_case:
    mov ax, [src1] - '0'
    add ax, [src2] - '0'
    jmp print_result

sub_case:
    mov ax, [src1] - '0'
    sub ax, [src2] - '0'
    jmp print_result

done:
    ; 显示消息4
    mov ah, 09h
    lea dx, msg4
    int 21h

print_result:
    mov dx, ax
    mov ah, 09h
    int 21h

end:
    nop

intend:
    iret
code ends
end start
```
